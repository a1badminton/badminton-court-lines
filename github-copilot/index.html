<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Badminton Court Trainer (Phaser, Imperial Units, Responsive, Reliable Hit Areas)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  <style>
    html, body { margin: 0; padding: 0; background: #f6f8fa; height: 100%; font-family: sans-serif; }
    #controls { text-align: center; margin: 1em; }
    button { margin: 0 0.5em 0.5em 0; padding: 0.5em 1em; font-size: 1em; border-radius: 5px; border: none; background: #1976d2; color: white; cursor: pointer;}
    button.secondary { background: #888; }
    #info { max-width: 700px; margin: 1em auto; background: #fff; border-radius: 8px; box-shadow: 0 0 12px #ccc; padding: 1em;}
    #phaser { margin: 0 auto; display: block;}
  </style>
</head>
<body>
  <header style="padding:1em;background:#1976d2;color:white;text-align:center;font-size:1.5em;">
    Badminton Court Trainer (Phaser, Imperial Units, Responsive, Reliable Hit Areas)
  </header>
  <div id="controls">
    <button id="teachBtn">Teach Mode</button>
    <button id="quizBtn" class="secondary">Quiz Mode</button>
  </div>
  <div id="info"></div>
  <div id="phaser"></div>
<script>
function getResponsiveScale() {
  const availableHeight = Math.max(window.innerHeight - 220, 350);
  return availableHeight / 528;
}

function getResponsiveConfig() {
  const scale = getResponsiveScale();
  const margin = 20;
  return {
    scale,
    margin,
    width_doubles: 240,
    length: 528,
    width_px: margin * 2 + 240 * scale,
    height_px: margin * 2 + 528 * scale
  };
}

let COURT = getCourtDimensions();

function getCourtDimensions() {
  const rc = getResponsiveConfig();
  return {
    scale: rc.scale,
    margin: rc.margin,
    length: 528,
    width_doubles: 240,
    width_singles: 204,
    net_y: 264,
    baseline_top: 0,
    baseline_bottom: 528,
    sideline_left_doubles: 0,
    sideline_right_doubles: 240,
    sideline_left_singles: 18,
    sideline_right_singles: 222,
    short_service_line_top: 186,
    short_service_line_bottom: 342,
    long_service_line_doubles_top: 30,
    long_service_line_doubles_bottom: 498,
    center_line_x: 120,
    width_px: rc.width_px,
    height_px: rc.height_px
  };
}

function toPx(inches) {
  return COURT.margin + inches * COURT.scale;
}

const HIT_SIZE = 12; // pixels

const getLines = () => [
  { id:'baseline-top', name:'Top Baseline', desc:'Back boundary (baseline), top of court.', coords:[COURT.sideline_left_doubles, COURT.baseline_top, COURT.sideline_right_doubles, COURT.baseline_top] },
  { id:'baseline-bottom', name:'Bottom Baseline', desc:'Back boundary (baseline), bottom of court.', coords:[COURT.sideline_left_doubles, COURT.baseline_bottom, COURT.sideline_right_doubles, COURT.baseline_bottom] },
  { id:'sideline-left-doubles', name:'Left Doubles Sideline', desc:'Left boundary for doubles.', coords:[COURT.sideline_left_doubles, COURT.baseline_top, COURT.sideline_left_doubles, COURT.baseline_bottom] },
  { id:'sideline-right-doubles', name:'Right Doubles Sideline', desc:'Right boundary for doubles.', coords:[COURT.sideline_right_doubles, COURT.baseline_top, COURT.sideline_right_doubles, COURT.baseline_bottom] },
  { id:'sideline-left-singles', name:'Left Singles Sideline', desc:'Left boundary for singles.', coords:[COURT.sideline_left_singles, COURT.baseline_top, COURT.sideline_left_singles, COURT.baseline_bottom] },
  { id:'sideline-right-singles', name:'Right Singles Sideline', desc:'Right boundary for singles.', coords:[COURT.sideline_right_singles, COURT.baseline_top, COURT.sideline_right_singles, COURT.baseline_bottom] },
  { id:'short-service-line-top', name:'Top Short Service Line', desc:'Line 6\'6" (78") from net, top side.', coords:[COURT.sideline_left_doubles, COURT.short_service_line_top, COURT.sideline_right_doubles, COURT.short_service_line_top] },
  { id:'short-service-line-bottom', name:'Bottom Short Service Line', desc:'Line 6\'6" (78") from net, bottom side.', coords:[COURT.sideline_left_doubles, COURT.short_service_line_bottom, COURT.sideline_right_doubles, COURT.short_service_line_bottom] },
  { id:'long-service-line-doubles-top', name:'Top Long Service Line (Doubles)', desc:'Line 2\'6" (30") in from top baseline for doubles service.', coords:[COURT.sideline_left_doubles, COURT.long_service_line_doubles_top, COURT.sideline_right_doubles, COURT.long_service_line_doubles_top] },
  { id:'long-service-line-doubles-bottom', name:'Bottom Long Service Line (Doubles)', desc:'Line 2\'6" (30") in from bottom baseline for doubles service.', coords:[COURT.sideline_left_doubles, COURT.long_service_line_doubles_bottom, COURT.sideline_right_doubles, COURT.long_service_line_doubles_bottom] },
  { id:'center-line-top', name:'Top Center Line', desc:'Divides left and right service courts, top side.', coords:[COURT.center_line_x, COURT.short_service_line_top, COURT.center_line_x, COURT.baseline_top] },
  { id:'center-line-bottom', name:'Bottom Center Line', desc:'Divides left and right service courts, bottom side.', coords:[COURT.center_line_x, COURT.short_service_line_bottom, COURT.center_line_x, COURT.baseline_bottom] },
  { id:'net', name:'Net (visual only)', desc:'Net location (not painted in real life).', coords:[COURT.sideline_left_doubles, COURT.net_y, COURT.sideline_right_doubles, COURT.net_y], net:true }
];

const getServiceCourts = () => [
  { id:'top-left-service', name:'Top Left Service Court', desc:'Left half, between top short service and top long service lines.', area:{
    x:COURT.sideline_left_singles, 
    y:COURT.short_service_line_top, 
    w:COURT.center_line_x-COURT.sideline_left_singles, 
    h:COURT.long_service_line_doubles_top-COURT.short_service_line_top
  }},
  { id:'top-right-service', name:'Top Right Service Court', desc:'Right half, between top short service and top long service lines.', area:{
    x:COURT.center_line_x, 
    y:COURT.short_service_line_top, 
    w:COURT.sideline_right_singles-COURT.center_line_x, 
    h:COURT.long_service_line_doubles_top-COURT.short_service_line_top
  }},
  { id:'bottom-left-service', name:'Bottom Left Service Court', desc:'Left half, between bottom short service and bottom long service lines.', area:{
    x:COURT.sideline_left_singles, 
    y:COURT.long_service_line_doubles_bottom, 
    w:COURT.center_line_x-COURT.sideline_left_singles, 
    h:COURT.short_service_line_bottom-COURT.long_service_line_doubles_bottom
  }},
  { id:'bottom-right-service', name:'Bottom Right Service Court', desc:'Right half, between bottom short service and bottom long service lines.', area:{
    x:COURT.center_line_x, 
    y:COURT.long_service_line_doubles_bottom, 
    w:COURT.sideline_right_singles-COURT.center_line_x, 
    h:COURT.short_service_line_bottom-COURT.long_service_line_doubles_bottom
  }}
];

let mode = 'teach';
let currentQuiz = null;
let score = 0;
let total = 0;
let game, scene;

function createPhaserGame() {
  if (game) { game.destroy(true); }
  COURT = getCourtDimensions();
  const config = {
    type: Phaser.AUTO,
    parent: 'phaser',
    width: COURT.width_px,
    height: COURT.height_px,
    backgroundColor: '#f6f8fa',
    scene: {
      create: create,
      restartCourt: restartCourt,
      showTeachCourt: showTeachCourt,
      showQuizCourt: showQuizCourt
    }
  };
  game = new Phaser.Game(config);
}

function create() {
  scene = this;
  this.graphics = this.add.graphics();
  restartCourt();

  this.lineObjs = getLines().map(line => {
    const color = line.net ? 0x888888 : 0x1976d2;
    const width = line.net ? 1 : 3;
    const x1 = toPx(line.coords[0]), y1 = toPx(line.coords[1]);
    const x2 = toPx(line.coords[2]), y2 = toPx(line.coords[3]);
    const obj = this.add.line(0, 0, x1, y1, x2, y2, color)
      .setLineWidth(width, width).setOrigin(0);

    // Larger hit area: rectangle
    let hitArea;
    if (x1 === x2) {
      // Vertical line
      hitArea = new Phaser.Geom.Rectangle(x1 - HIT_SIZE/2, Math.min(y1, y2), HIT_SIZE, Math.abs(y2-y1));
    } else if (y1 === y2) {
      // Horizontal line
      hitArea = new Phaser.Geom.Rectangle(Math.min(x1, x2), y1 - HIT_SIZE/2, Math.abs(x2-x1), HIT_SIZE);
    } else {
      // Diagonal (not expected here, but robust)
      hitArea = new Phaser.Geom.Rectangle(
        Math.min(x1,x2) - HIT_SIZE/2, Math.min(y1,y2) - HIT_SIZE/2,
        Math.abs(x2-x1) + HIT_SIZE, Math.abs(y2-y1) + HIT_SIZE
      );
    }
    obj.setInteractive({ useHandCursor: true, hitArea, hitAreaCallback: Phaser.Geom.Rectangle.Contains });

    obj.data = new Phaser.Data.DataManager(obj);
    obj.data.set('name', line.name);
    obj.data.set('desc', line.desc);
    obj.data.set('id', line.id);
    return obj;
  });

  this.serviceObjs = getServiceCourts().map(area => {
    const obj = this.add.rectangle(
      toPx(area.area.x + area.area.w/2),
      toPx(area.area.y + area.area.h/2),
      Math.abs(toPx(area.area.w)),
      Math.abs(toPx(area.area.h)),
      0xe3f2fd, 0.01
    );
    obj.setInteractive({ useHandCursor: true });
    obj.data = new Phaser.Data.DataManager(obj);
    obj.data.set('name', area.name);
    obj.data.set('desc', area.desc);
    obj.data.set('id', area.id);
    return obj;
  });

  this.input.on('pointermove', function (pointer) {
    let highlighted = false;
    [...scene.lineObjs, ...scene.serviceObjs].forEach(obj => {
      if (obj.input && obj.input.enabled &&
        ((obj.type === 'Line' && Phaser.Geom.Rectangle.Contains(obj.input.hitArea, pointer.x, pointer.y)) ||
         (obj.type === 'Rectangle' && Phaser.Geom.Rectangle.Contains(obj.input.hitArea, pointer.x, pointer.y)))
      ) {
        highlightObject(obj, true);
        highlighted = true;
      } else {
        highlightObject(obj, false);
      }
    });
    if (!highlighted) {
      if (mode === 'teach') info('Tap a line or service court to learn its name and purpose.', '');
    }
  });

  this.input.on('gameobjectdown', (pointer, obj) => {
    if (mode === 'teach') {
      info(obj.data.get('name'), obj.data.get('desc'));
      highlightObject(obj, true);
    } else if (mode === 'quiz') {
      if (currentQuiz && currentQuiz.id === obj.data.get('id')) {
        score++; feedback(`✅ Correct! (${score}/${total})`);
        highlightObject(obj, true);
      } else {
        feedback(`❌ Incorrect. That was ${obj.data.get('name')}. (${score}/${total})`);
        highlightQuizObject(currentQuiz.id);
      }
      setTimeout(nextQuizQuestion, 1200);
    }
  });
}

function restartCourt() {
  scene.graphics.clear();
  scene.graphics.lineStyle(3, 0x000000);
  scene.graphics.strokeRect(
    toPx(COURT.sideline_left_doubles), toPx(COURT.baseline_top),
    toPx(COURT.width_doubles), toPx(COURT.length) - toPx(0)
  );
  scene.graphics.lineStyle(3, 0x1976d2);
  scene.graphics.strokeRect(
    toPx(COURT.sideline_left_singles), toPx(COURT.baseline_top),
    toPx(COURT.width_singles), toPx(COURT.length) - toPx(0)
  );
  getServiceCourts().forEach(sc => {
    scene.graphics.fillStyle(0xe3f2fd, 0.3);
    scene.graphics.fillRect(
      toPx(sc.area.x), toPx(sc.area.y),
      Math.abs(toPx(sc.area.w)), Math.abs(toPx(sc.area.h))
    );
  });
}

function info(name, desc) {
  document.getElementById('info').innerHTML = `<h3>${name}</h3><p>${desc}</p>`;
}
function feedback(msg) {
  document.getElementById('info').innerHTML = `<div style="font-weight:bold">${msg}</div>`;
}
function highlightObject(obj, active) {
  if (obj.type === 'Line') {
    if (active) obj.setStrokeStyle(10, 0xff9800);
    else obj.setStrokeStyle(obj.data.get('id') === 'net' ? 1 : 3, obj.data.get('id') === 'net' ? 0x888888 : 0x1976d2);
  } else if (obj.type === 'Rectangle') {
    if (active) obj.setFillStyle(0xff9800, 0.4);
    else obj.setFillStyle(0xe3f2fd, 0.01);
  }
}
function highlightQuizObject(id) {
  [...scene.lineObjs, ...scene.serviceObjs].forEach(o => {
    highlightObject(o, o.data.get('id') === id);
  });
}

function showTeachCourt() {
  mode = 'teach';
  score = 0; total = 0; currentQuiz = null;
  restartCourt();
  info('Tap a line or service court to learn its name and purpose.', '');
  [...scene.lineObjs, ...scene.serviceObjs].forEach(o => highlightObject(o, false));
}
function showQuizCourt() {
  mode = 'quiz';
  score = 0; total = 0;
  restartCourt();
  nextQuizQuestion();
}
function nextQuizQuestion() {
  total++;
  currentQuiz = Phaser.Utils.Array.GetRandom([...getLines(), ...getServiceCourts()]);
  feedback(`<b>Which line or area is: <span style="color:#1976d2">${currentQuiz.name}</span>?</b><br><small>Tap on the court to answer.</small>`);
  highlightQuizObject(null);
}

document.getElementById('teachBtn').onclick = () => { scene.showTeachCourt(); };
document.getElementById('quizBtn').onclick = () => { scene.showQuizCourt(); };

window.addEventListener('resize', () => {
  createPhaserGame();
  setTimeout(() => {
    if (mode === 'teach') showTeachCourt();
    else showQuizCourt();
  }, 100);
});

createPhaserGame();
</script>
</body>
</html>