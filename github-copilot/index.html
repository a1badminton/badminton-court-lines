<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Badminton Court Trainer (Phaser, Imperial Units)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
  <style>
    body { margin: 0; padding: 0; background: #f6f8fa; font-family: sans-serif; }
    #controls { text-align: center; margin: 1em; }
    button { margin: 0 0.5em 0.5em 0; padding: 0.5em 1em; font-size: 1em; border-radius: 5px; border: none; background: #1976d2; color: white; cursor: pointer;}
    button.secondary { background: #888; }
    #info { max-width: 700px; margin: 1em auto; background: #fff; border-radius: 8px; box-shadow: 0 0 12px #ccc; padding: 1em;}
    #phaser { margin: 0 auto; display: block; }
  </style>
</head>
<body>
  <header style="padding:1em;background:#1976d2;color:white;text-align:center;font-size:1.5em;">
    Badminton Court Trainer (Phaser, Imperial Units)
  </header>
  <div id="controls">
    <button id="teachBtn">Teach Mode</button>
    <button id="quizBtn" class="secondary">Quiz Mode</button>
  </div>
  <div id="info"></div>
  <div id="phaser"></div>

<script>
const COURT = {
  scale: 1.5, // scale inches to pixels
  margin: 40, // pixels
  length: 528, // 44 ft
  width_doubles: 240, // 20 ft
  width_singles: 204, // 17 ft
  net_y: 264, // halfway
  baseline_top: 0,
  baseline_bottom: 528,
  sideline_left_doubles: 0,
  sideline_right_doubles: 240,
  sideline_left_singles: 18, // (240-204)/2
  sideline_right_singles: 222, // 240-18
  short_service_line_top: 264 - 78, // 186
  short_service_line_bottom: 264 + 78, // 342
  long_service_line_doubles_top: 30, // 2'6" from top
  long_service_line_doubles_bottom: 528 - 30, // 498
  center_line_x: 120, // half doubles width
};

function toPx(inches) {
  return COURT.margin + inches * COURT.scale;
}

const LINES = [
  // Baselines
  { id:'baseline-top', name:'Top Baseline', desc:'Back boundary (baseline), top of court.', coords:[COURT.sideline_left_doubles, COURT.baseline_top, COURT.sideline_right_doubles, COURT.baseline_top] },
  { id:'baseline-bottom', name:'Bottom Baseline', desc:'Back boundary (baseline), bottom of court.', coords:[COURT.sideline_left_doubles, COURT.baseline_bottom, COURT.sideline_right_doubles, COURT.baseline_bottom] },
  // Doubles sidelines
  { id:'sideline-left-doubles', name:'Left Doubles Sideline', desc:'Left boundary for doubles.', coords:[COURT.sideline_left_doubles, COURT.baseline_top, COURT.sideline_left_doubles, COURT.baseline_bottom] },
  { id:'sideline-right-doubles', name:'Right Doubles Sideline', desc:'Right boundary for doubles.', coords:[COURT.sideline_right_doubles, COURT.baseline_top, COURT.sideline_right_doubles, COURT.baseline_bottom] },
  // Singles sidelines
  { id:'sideline-left-singles', name:'Left Singles Sideline', desc:'Left boundary for singles.', coords:[COURT.sideline_left_singles, COURT.baseline_top, COURT.sideline_left_singles, COURT.baseline_bottom] },
  { id:'sideline-right-singles', name:'Right Singles Sideline', desc:'Right boundary for singles.', coords:[COURT.sideline_right_singles, COURT.baseline_top, COURT.sideline_right_singles, COURT.baseline_bottom] },
  // Short service lines (full width)
  { id:'short-service-line-top', name:'Top Short Service Line', desc:'Line 6\'6" (78") from net, top side.', coords:[COURT.sideline_left_doubles, COURT.short_service_line_top, COURT.sideline_right_doubles, COURT.short_service_line_top] },
  { id:'short-service-line-bottom', name:'Bottom Short Service Line', desc:'Line 6\'6" (78") from net, bottom side.', coords:[COURT.sideline_left_doubles, COURT.short_service_line_bottom, COURT.sideline_right_doubles, COURT.short_service_line_bottom] },
  // Long service lines for doubles
  { id:'long-service-line-doubles-top', name:'Top Long Service Line (Doubles)', desc:'Line 2\'6" (30") in from top baseline for doubles service.', coords:[COURT.sideline_left_doubles, COURT.long_service_line_doubles_top, COURT.sideline_right_doubles, COURT.long_service_line_doubles_top] },
  { id:'long-service-line-doubles-bottom', name:'Bottom Long Service Line (Doubles)', desc:'Line 2\'6" (30") in from bottom baseline for doubles service.', coords:[COURT.sideline_left_doubles, COURT.long_service_line_doubles_bottom, COURT.sideline_right_doubles, COURT.long_service_line_doubles_bottom] },
  // Center lines (each side: from short service line to baseline)
  { id:'center-line-top', name:'Top Center Line', desc:'Divides left and right service courts, top side.', coords:[COURT.center_line_x, COURT.short_service_line_top, COURT.center_line_x, COURT.baseline_top] },
  { id:'center-line-bottom', name:'Bottom Center Line', desc:'Divides left and right service courts, bottom side.', coords:[COURT.center_line_x, COURT.short_service_line_bottom, COURT.center_line_x, COURT.baseline_bottom] },
  // Net (visual only)
  { id:'net', name:'Net (visual only)', desc:'Net location (not painted in real life).', coords:[COURT.sideline_left_doubles, COURT.net_y, COURT.sideline_right_doubles, COURT.net_y], net:true }
];

const SERVICE_COURTS = [
  { id:'top-left-service', name:'Top Left Service Court', desc:'Left half, in front of top short service line.', area:{
    x:COURT.sideline_left_singles, y:COURT.short_service_line_top, w:COURT.center_line_x-COURT.sideline_left_singles, h:COURT.net_y-COURT.short_service_line_top
  }},
  { id:'top-right-service', name:'Top Right Service Court', desc:'Right half, in front of top short service line.', area:{
    x:COURT.center_line_x, y:COURT.short_service_line_top, w:COURT.sideline_right_singles-COURT.center_line_x, h:COURT.net_y-COURT.short_service_line_top
  }},
  { id:'bottom-left-service', name:'Bottom Left Service Court', desc:'Left half, behind bottom short service line.', area:{
    x:COURT.sideline_left_singles, y:COURT.net_y, w:COURT.center_line_x-COURT.sideline_left_singles, h:COURT.short_service_line_bottom-COURT.net_y
  }},
  { id:'bottom-right-service', name:'Bottom Right Service Court', desc:'Right half, behind bottom short service line.', area:{
    x:COURT.center_line_x, y:COURT.net_y, w:COURT.sideline_right_singles-COURT.center_line_x, h:COURT.short_service_line_bottom-COURT.net_y
  }}
];

let mode = 'teach';
let currentQuiz = null;
let score = 0;
let total = 0;

const config = {
  type: Phaser.AUTO,
  parent: 'phaser',
  width: toPx(COURT.width_doubles),
  height: toPx(COURT.length),
  backgroundColor: '#f6f8fa',
  scene: {
    create: create,
    restartCourt: restartCourt,
    showTeachCourt: showTeachCourt,
    showQuizCourt: showQuizCourt
  }
};

let game, scene;

function create() {
  scene = this;
  this.graphics = this.add.graphics();
  this.lineObjs = [];
  this.serviceObjs = [];
  restartCourt();

  // Hover feedback for lines
  this.input.on('pointermove', function (pointer) {
    let found = false;
    [...scene.lineObjs, ...scene.serviceObjs].forEach(obj => {
      if (obj.input && obj.input.enabled && obj.input.hitArea && obj.input.hitAreaCallback &&
          obj.input.hitAreaCallback(obj.input.hitArea, pointer.x, pointer.y)) {
        if (!obj.data.get('hovered')) {
          obj.data.set('hovered', true);
          highlightObject(obj, true);
        }
        found = true;
      } else if (obj.data.get('hovered')) {
        obj.data.set('hovered', false);
        highlightObject(obj, false);
      }
    });
    if (!found) {
      restartCourt(); // Remove all highlights if nothing hovered
    }
  });

  this.input.on('gameobjectdown', (pointer, obj) => {
    if (mode === 'teach') {
      info(obj.data.get('name'), obj.data.get('desc'));
      highlightObject(obj, true);
    } else if (mode === 'quiz') {
      if (currentQuiz && currentQuiz.id === obj.data.get('id')) {
        score++; feedback(`✅ Correct! (${score}/${total})`);
        highlightObject(obj, true);
      } else {
        feedback(`❌ Incorrect. That was ${obj.data.get('name')}. (${score}/${total})`);
        highlightQuizObject(currentQuiz.id);
      }
      setTimeout(nextQuizQuestion, 1200);
    }
  });
}

function restartCourt() {
  scene.graphics.clear();
  drawCourt();
  makeInteractiveLines();
  makeInteractiveServiceCourts();
}

function drawCourt() {
  // Outer doubles boundary
  scene.graphics.lineStyle(4, 0x000000);
  scene.graphics.strokeRect(
    toPx(COURT.sideline_left_doubles), toPx(COURT.baseline_top),
    toPx(COURT.width_doubles), toPx(COURT.length) - toPx(0)
  );
  // Singles boundary
  scene.graphics.lineStyle(2, 0x1976d2);
  scene.graphics.strokeRect(
    toPx(COURT.sideline_left_singles), toPx(COURT.baseline_top),
    toPx(COURT.width_singles), toPx(COURT.length) - toPx(0)
  );
  // Service courts fill
  SERVICE_COURTS.forEach(sc => {
    scene.graphics.fillStyle(0xe3f2fd, 0.3);
    scene.graphics.fillRect(
      toPx(sc.area.x), toPx(sc.area.y),
      toPx(sc.area.w), toPx(sc.area.h)
    );
  });
}

function makeInteractiveLines() {
  scene.lineObjs.forEach(obj => obj.destroy());
  scene.lineObjs = LINES.map(line => {
    const color = line.net ? 0x888888 : 0x1976d2;
    const width = line.net ? 2 : 6;
    const obj = scene.add.line(0, 0,
      toPx(line.coords[0]), toPx(line.coords[1]),
      toPx(line.coords[2]), toPx(line.coords[3]),
      color
    ).setLineWidth(width, width).setOrigin(0);

    obj.setInteractive({ useHandCursor: true, hitArea: new Phaser.Geom.Line(
      toPx(line.coords[0]), toPx(line.coords[1]),
      toPx(line.coords[2]), toPx(line.coords[3])
    ), hitAreaCallback: Phaser.Geom.Line.Contains });
    obj.data = new Phaser.Data.DataManager(obj);
    obj.data.set('name', line.name);
    obj.data.set('desc', line.desc);
    obj.data.set('id', line.id);
    obj.data.set('hovered', false);
    return obj;
  });
}

function makeInteractiveServiceCourts() {
  scene.serviceObjs.forEach(obj => obj.destroy());
  scene.serviceObjs = SERVICE_COURTS.map(area => {
    const obj = scene.add.rectangle(
      toPx(area.area.x + area.area.w/2),
      toPx(area.area.y + area.area.h/2),
      toPx(area.area.w),
      toPx(area.area.h),
      0xe3f2fd, 0.01
    );
    obj.setInteractive({ useHandCursor: true });
    obj.data = new Phaser.Data.DataManager(obj);
    obj.data.set('name', area.name);
    obj.data.set('desc', area.desc);
    obj.data.set('id', area.id);
    obj.data.set('hovered', false);
    return obj;
  });
}

function info(name, desc) {
  document.getElementById('info').innerHTML = `<h3>${name}</h3><p>${desc}</p>`;
}
function feedback(msg) {
  document.getElementById('info').innerHTML = `<div style="font-weight:bold">${msg}</div>`;
}
function highlightObject(obj, hover) {
  restartCourt();
  if (obj.type === 'Line') {
    if (hover) obj.setStrokeStyle(16, 0xff9800);
    else obj.setStrokeStyle(obj.data.get('id') === 'net' ? 2 : 6, obj.data.get('id') === 'net' ? 0x888888 : 0x1976d2);
  } else if (obj.type === 'Rectangle') {
    if (hover) obj.setFillStyle(0xff9800, 0.4);
    else obj.setFillStyle(0xe3f2fd, 0.01);
  }
}
function highlightQuizObject(id) {
  restartCourt();
  [...scene.lineObjs, ...scene.serviceObjs].forEach(o => {
    if (o.data.get('id') === id) highlightObject(o, true);
  });
}

function showTeachCourt() {
  mode = 'teach';
  score = 0; total = 0; currentQuiz = null;
  restartCourt();
  info('Tap a line or service court to learn its name and purpose.', '');
}
function showQuizCourt() {
  mode = 'quiz';
  score = 0; total = 0;
  restartCourt();
  nextQuizQuestion();
}
function nextQuizQuestion() {
  total++;
  currentQuiz = Phaser.Utils.Array.GetRandom([...LINES, ...SERVICE_COURTS]);
  feedback(`<b>Which line or area is: <span style="color:#1976d2">${currentQuiz.name}</span>?</b><br><small>Tap on the court to answer.</small>`);
  highlightQuizObject(null);
}

// UI events
document.getElementById('teachBtn').onclick = () => { scene.showTeachCourt(); };
document.getElementById('quizBtn').onclick = () => { scene.showQuizCourt(); };

// Start game
game = new Phaser.Game(config);

</script>
</body>
</html>